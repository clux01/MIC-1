-- VHDL Entity IP006_lib.uart_tx.symbol
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 07:19:41 26.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY uart_tx IS
   GENERIC( 
      baudrate_g      : integer := 9600;
      core_clk_freq_g : integer := 50000000
   );
   PORT( 
      clk    : IN     std_logic;                      -- core clock
      din    : IN     std_logic_vector (7 DOWNTO 0);  -- parallel tx data input
      reset  : IN     std_logic;                      -- synchronous, active high reset
      we     : IN     std_logic;                      -- data write enable
      tx_ack : OUT    std_logic;                      -- transmit acknowledge
      txd    : OUT    std_logic                       -- serial  transmit data
   );

-- Declarations

END uart_tx ;

--
-- VHDL Architecture IP006_lib.uart_tx.fsm
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 07:19:41 26.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
 
ARCHITECTURE fsm OF uart_tx IS

   -- Architecture Declarations
   -- reload value for the baudrate timer --------------------------------------------------
   constant bdcnt_mod_c: integer :=  core_clk_freq_g / baudrate_g;
   
   signal bdcnt_en: std_logic;
   signal bdcnt_tc: std_logic;
   signal bdcnt: integer range 0 to bdcnt_mod_c-1;
   signal tx_reg: std_logic_vector(din'left+2 downto 0);
   signal bit_cnt: integer range 0 to din'length+1;

   TYPE STATE_TYPE IS (
      s_wait,
      s_tx
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL tx_ack_cld : std_logic ;-- transmit acknowledge

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk
   )
   -----------------------------------------------------------------
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset = '1') THEN
            current_state <= s_wait;
            -- Default Reset Values
            tx_ack_cld <= '0';
            tx_reg <= (others => '1');
         ELSE
            current_state <= next_state;
            -- Default Assignment To Internals
            tx_ack_cld <= '0';

            -- Combined Actions
            CASE current_state IS
               WHEN s_wait => 
                  IF (we = '1') THEN 
                     tx_reg <= '1' & din & '0';
                     bit_cnt <= din'length+1;
                  END IF;
               WHEN s_tx => 
                  IF (bdcnt_tc = '1' and bit_cnt = 0) THEN 
                     tx_ack_cld <= '1';
                  ELSIF (bdcnt_tc = '1') THEN 
                     tx_reg <= '1' & tx_reg(tx_reg'left downto 1);
                     bit_cnt <= bit_cnt -1;
                  END IF;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      bdcnt_tc,
      bit_cnt,
      current_state,
      we
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN s_wait => 
            IF (we = '1') THEN 
               next_state <= s_tx;
            ELSE
               next_state <= s_wait;
            END IF;
         WHEN s_tx => 
            IF (bdcnt_tc = '1' and bit_cnt = 0) THEN 
               next_state <= s_wait;
            ELSIF (bdcnt_tc = '1') THEN 
               next_state <= s_tx;
            ELSE
               next_state <= s_tx;
            END IF;
         WHEN OTHERS =>
            next_state <= s_wait;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment To Internals
      bdcnt_en <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN s_tx => 
            bdcnt_en <= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   tx_ack <= tx_ack_cld;
   -- baudrate counter ----------
   process(clk)
   begin
      if clk='1' and clk'event then
         if bdcnt_en = '0'  then
             bdcnt <= 0;
         else
             if bdcnt_tc = '1' then
                 bdcnt <= 0;
             else
               bdcnt <= bdcnt + 1;
             end if;
         end if;
     end if;
   end process;
   
   bdcnt_tc <= '1' when bdcnt = bdcnt_mod_c - 1 else '0';
   
   txd <= tx_reg(0);
END fsm;
