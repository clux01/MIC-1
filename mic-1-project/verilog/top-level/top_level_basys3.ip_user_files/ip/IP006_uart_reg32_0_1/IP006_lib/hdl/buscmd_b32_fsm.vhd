-- VHDL Entity IP006_lib.buscmd_b32.symbol
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 14:03:57 08.03.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

Library std;
use std.textio.all;

ENTITY buscmd_b32 IS
   GENERIC( 
      COMMANDS : string := "buscommands.txt"
   );
   PORT( 
      bus_addr    : OUT    std_logic_vector ( 15 DOWNTO 0 );
      bus_we      : OUT    std_logic;
      bus_dout    : OUT    std_logic_vector (31 DOWNTO 0);
      bus_rd      : OUT    std_logic;
      bus_din     : IN     std_logic_vector (31 DOWNTO 0);
      clk         : IN     std_logic;
      reset       : IN     std_logic;
      bus_ack     : IN     std_logic;
      eof         : OUT    std_logic;
      bus_request : OUT    std_logic;
      bus_grant   : IN     std_logic
   );

-- Declarations

END buscmd_b32 ;

--
-- VHDL Architecture IP006_lib.buscmd_b32.fsm
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 12:24:29 12.03.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
LIBRARY std;
USE std.textio.all;
 
ARCHITECTURE fsm OF buscmd_b32 IS

   -- Architecture Declarations
   signal bus_address_int: std_logic_vector(15 downto 0) := (others => '0');
   signal bus_data_int: std_logic_vector(15 downto 0) := (others => '0');
   signal bus_din_int: std_logic_vector(15 downto 0);
   signal bus_data_en: std_logic;
   signal next_cmd: std_logic := '0';
   signal rnw: std_logic;
   signal stop: std_logic := '0';
   signal halt: std_logic := '0';
   signal data_en: std_logic;
   
   
   ------convert string with 8 elements to 32-bit standard logic vector 
   
   function STR8_2VEC (str: string (8 downto 1)) return std_logic_vector is
      variable vec: std_logic_vector(31 downto 0);
      variable tmp: std_logic_vector(3 downto 0);
   begin
       for i in 0 to 7 loop
          case str(i+1) is
             when '0'=> tmp := "0000";
             when '1'=> tmp := "0001";
             when '2'=> tmp := "0010";
             when '3'=> tmp := "0011";
             when '4'=> tmp := "0100";
             when '5'=> tmp := "0101";
             when '6'=> tmp := "0110";
             when '7'=> tmp := "0111";
             when '8'=> tmp := "1000";
             when '9'=> tmp := "1001";
             when 'A'=> tmp := "1010";
             when 'B'=> tmp := "1011";
             when 'C'=> tmp := "1100";
             when 'D'=> tmp := "1101";
             when 'E'=> tmp := "1110";
             when 'F'=> tmp := "1111";
             when others =>  tmp := "XXXX";
           end case;
           vec(4*i+3 downto 4*i) := tmp;
       end loop;
       return(vec);
   end STR8_2VEC;
   
   function STR4_2VEC (str: string (4 downto 1)) return std_logic_vector is
      variable vec: std_logic_vector(15 downto 0);
      variable tmp: std_logic_vector(3 downto 0);
   begin
       for i in 0 to 3 loop
          case str(i+1) is
             when '0'=> tmp := "0000";
             when '1'=> tmp := "0001";
             when '2'=> tmp := "0010";
             when '3'=> tmp := "0011";
             when '4'=> tmp := "0100";
             when '5'=> tmp := "0101";
             when '6'=> tmp := "0110";
             when '7'=> tmp := "0111";
             when '8'=> tmp := "1000";
             when '9'=> tmp := "1001";
             when 'A'=> tmp := "1010";
             when 'B'=> tmp := "1011";
             when 'C'=> tmp := "1100";
             when 'D'=> tmp := "1101";
             when 'E'=> tmp := "1110";
             when 'F'=> tmp := "1111";
             when others =>  tmp := "XXXX";
           end case;
           vec(4*i+3 downto 4*i) := tmp;
       end loop;
       return(vec);
   end STR4_2VEC;

   TYPE STATE_TYPE IS (
      s_reset,
      s_exec,
      s_write,
      s_read,
      s_fetch,
      s_busarb
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk
   )
   -----------------------------------------------------------------
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset = '1') THEN
            current_state <= s_reset;
            -- Default Reset Values
            next_cmd <= '0';
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN s_fetch => 
                  IF (halt = '0' and stop = '0') THEN 
                     next_cmd <= not next_cmd;
                  END IF;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      bus_ack,
      bus_grant,
      current_state,
      halt,
      rnw,
      stop
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN s_reset => 
            next_state <= s_fetch;
         WHEN s_exec => 
            IF (rnw = '0') THEN 
               next_state <= s_write;
            ELSE
               next_state <= s_read;
            END IF;
         WHEN s_write => 
            IF (bus_ack = '1') THEN 
               next_state <= s_fetch;
            ELSE
               next_state <= s_write;
            END IF;
         WHEN s_read => 
            IF (bus_ack = '1') THEN 
               next_state <= s_fetch;
            ELSE
               next_state <= s_read;
            END IF;
         WHEN s_fetch => 
            IF (halt = '0' and stop = '0') THEN 
               next_state <= s_busarb;
            ELSE
               next_state <= s_fetch;
            END IF;
         WHEN s_busarb => 
            IF (stop = '1' or halt = '1') THEN 
               next_state <= s_fetch;
            ELSIF (bus_grant = '1') THEN 
               next_state <= s_exec;
            ELSE
               next_state <= s_busarb;
            END IF;
         WHEN OTHERS =>
            next_state <= s_reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      bus_we <= '0';
      bus_rd <= '0';
      bus_request <= '1';
      -- Default Assignment To Internals
      data_en <= '1';

      -- Combined Actions
      CASE current_state IS
         WHEN s_reset => 
            bus_request <= '0';
            data_en <= '0';
         WHEN s_write => 
            bus_we <= '1';
         WHEN s_read => 
            bus_rd <= '1';
         WHEN s_fetch => 
            bus_request <= '0';
            data_en <= '0';
         WHEN s_busarb => 
            data_en <= '0';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
   -- Concurrent Statements
   -- synthesis translate_off
   ------------------------------------------------------------------------------
   ---Read Command File
   ------------------------------------------------------------------------------
   
       readcmd:process
       file textfile:   text is in COMMANDS;
       variable l: line;
       variable cmd:  string(1 to 4);
       variable address: string(1 to 4);
       variable data: string(1 to 4);
       variable num: integer;
       variable separator: character;
       variable timestamp_v, waittime_v: time;
       begin
          while not endfile(textfile) loop
             wait until next_cmd'event;  
            readline(textfile, l);
            read(l, cmd);
            case cmd is
               when "MEMW" =>    read(l,separator);
                                 read(l,address);
                                 read(l,separator);
                                 read(l,data);
                                 bus_address_int <= STR4_2VEC(address);
                                 bus_data_int <= STR4_2VEC(data); 
                                 rnw <= '0';
                 when "MEMR" =>  read(l,separator);
                                 read(l,address);
                                 bus_address_int <= STR4_2VEC(address);
                                 rnw <= '1';
                 when "TIME" =>  read(l,separator);
                                 read(l,timestamp_v);
                                waittime_v := timestamp_v - now;
                                halt <= '1';
                                wait for waittime_v;  
                                halt <= '0';
    
   
                when others =>   assert false report "Unrecognised Instruction"
                                 severity failure;
            end case;                    
         
         end loop;
         stop <= '1';
         assert false report "Simulation complete" severity note;
   
         wait;
   
       end process readcmd;
   
   -- assign internal signals to output ports ---
   bus_addr <= bus_address_int(bus_addr'range) when data_en = '1' else (others => '0');
    
   bus_dout <= bus_data_int(bus_data_int'range) & x"0000" when data_en = '1' else (others => '0');
   
   eof <= not stop;
   
   -- synthesis translate_on
END fsm;
