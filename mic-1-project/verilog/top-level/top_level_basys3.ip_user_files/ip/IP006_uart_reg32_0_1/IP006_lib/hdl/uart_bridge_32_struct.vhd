-- VHDL Entity IP006_lib.uart_bridge_32.symbol
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 13:18:11 08.03.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_arith.ALL;
USE ieee.std_logic_unsigned.ALL;
LIBRARY IP006_LIB;
USE IP006_LIB.busdef.ALL;

ENTITY uart_bridge_32 IS
   GENERIC( 
      core_clk_freq_g : integer := 50000000;
      baudrate_g      : integer := 115200;
      simulate_g      : boolean := false;
      commandfile_g   : string  := "command.txt"
   );
   PORT( 
      clk    : IN     std_logic;
      mbus_i : IN     mbus32_i_t;
      reset  : IN     std_logic;
      rxd    : IN     std_logic;
      mbus_o : OUT    mbus32_o_t;
      txd    : OUT    std_logic
   );

-- Declarations

END uart_bridge_32 ;

--
-- VHDL Architecture IP006_lib.uart_bridge_32.struct
--
-- Created:
--          by - lamplpat.UNKNOWN (M00159)
--          at - 12:27:44 12.03.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_arith.ALL;
USE ieee.std_logic_unsigned.ALL;
LIBRARY IP006_LIB;
USE IP006_LIB.busdef.ALL;
LIBRARY std;
USE std.textio.ALL;


ARCHITECTURE struct OF uart_bridge_32 IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL bus_ack     : std_logic;
   SIGNAL bus_addr    : std_logic_vector(15 DOWNTO 0);
   SIGNAL bus_din     : std_logic_vector(31 DOWNTO 0);
   SIGNAL bus_grant   : std_logic;
   SIGNAL bus_dout    : std_logic_vector(31 DOWNTO 0);
   SIGNAL bus_request : std_logic;
   SIGNAL bus_rd      : std_logic;
   SIGNAL bus_we      : std_logic;
   SIGNAL cmd         : std_logic_vector(7 DOWNTO 0);
   SIGNAL cmd_we      : std_logic;
   SIGNAL eof         : std_logic;
   SIGNAL response    : std_logic_vector(7 DOWNTO 0);
   SIGNAL response_en : std_logic;
   SIGNAL slv_ack     : std_logic;
   SIGNAL slv_cs      : std_logic;
   SIGNAL slv_din     : std_logic;
   SIGNAL slv_we      : std_logic;
   SIGNAL tx_ack      : std_logic;                        -- transmit acknowledge


-- attribute keep: string;
-- attribute mark_debug: string;
-- attribute keep of cmd : signal is "true";
-- attribute mark_debug of cmd : signal is "true";
-- attribute keep of cmd_we : signal is "true";
-- attribute mark_debug of cmd_we : signal is "true";
-- attribute keep of tx_ack : signal is "true";
-- attribute mark_debug of tx_ack : signal is "true";
-- attribute keep of response : signal is "true";
-- attribute mark_debug of response : signal is "true";
-- attribute keep of response_en : signal is "true";
-- attribute mark_debug of response_en : signal is "true";
-- attribute keep of reset : signal is "true";
-- attribute mark_debug of reset : signal is "true";

   -- Component Declarations
   COMPONENT bus_bridge_32
   PORT (
      bus_ack     : IN     std_logic ;
      bus_din     : IN     std_logic_vector (31 DOWNTO 0);
      bus_grant   : IN     std_logic ;
      clk         : IN     std_logic ;
      cmd         : IN     std_logic_vector (7 DOWNTO 0);
      cmd_we      : IN     std_logic ;
      reset       : IN     std_logic ;
      slv_cs      : IN     std_logic ;
      slv_din     : IN     std_logic ;
      slv_we      : IN     std_logic ;
      tx_ack      : IN     std_logic ;
      bus_addr    : OUT    std_logic_vector ( 15 DOWNTO 0 );
      bus_dout    : OUT    std_logic_vector (31 DOWNTO 0);
      bus_rd      : OUT    std_logic ;
      bus_request : OUT    std_logic ;
      bus_we      : OUT    std_logic ;
      response    : OUT    std_logic_vector (7 DOWNTO 0);
      response_en : OUT    std_logic ;
      slv_ack     : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT buscmd_b32
   GENERIC (
      COMMANDS : string := "buscommands.txt"
   );
   PORT (
      bus_addr    : OUT    std_logic_vector ( 15 DOWNTO 0 );
      bus_we      : OUT    std_logic ;
      bus_dout    : OUT    std_logic_vector (31 DOWNTO 0);
      bus_rd      : OUT    std_logic ;
      bus_din     : IN     std_logic_vector (31 DOWNTO 0);
      clk         : IN     std_logic ;
      reset       : IN     std_logic ;
      bus_ack     : IN     std_logic ;
      eof         : OUT    std_logic ;
      bus_request : OUT    std_logic ;
      bus_grant   : IN     std_logic 
   );
   END COMPONENT;
   COMPONENT uart_top
   GENERIC (
      core_clk_freq_g : integer := 50000000;
      baudrate_g      : integer := 9600
   );
   PORT (
      clk    : IN     std_logic ;
      din    : IN     std_logic_vector (7 DOWNTO 0);
      reset  : IN     std_logic ;
      rxd    : IN     std_logic ;
      we     : IN     std_logic ;
      dout   : OUT    std_logic_vector (7 DOWNTO 0);
      rx_ack : OUT    std_logic ;
      tx_ack : OUT    std_logic ;                  -- transmit acknowledge
      txd    : OUT    std_logic 
   );
   END COMPONENT;


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   -- eb1 1           
   mbus_o.addr <= bus_addr when bus_grant = '1' else (others => '0');
   mbus_o.wdata <= bus_dout when bus_grant = '1' else (others => '0');
   mbus_o.we <= bus_we when bus_grant = '1' else '0';
   mbus_o.rd <= bus_rd when bus_grant = '1' else '0';
   mbus_o.req <= bus_request;
   bus_din <= mbus_i.rdata;
   bus_ack <= mbus_i.ack;
   bus_grant <= mbus_i.grant;                             


   -- Instance port mappings.

   g0: IF not simulate_g GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : bus_bridge_32 USE ENTITY IP006_lib.bus_bridge_32;
   FOR ALL : uart_top USE ENTITY IP006_lib.uart_top;
   -- pragma synthesis_on

   BEGIN
      I6 : uart_top
         GENERIC MAP (
            core_clk_freq_g => core_clk_freq_g,
            baudrate_g      => baudrate_g
         )
         PORT MAP (
            clk    => clk,
            din    => response,
            reset  => reset,
            rxd    => rxd,
            we     => response_en,
            dout   => cmd,
            rx_ack => cmd_we,
            tx_ack => tx_ack,
            txd    => txd
         );
      I0 : bus_bridge_32
         PORT MAP (
            bus_ack     => bus_ack,
            bus_din     => bus_din,
            bus_grant   => bus_grant,
            clk         => clk,
            cmd         => cmd,
            cmd_we      => cmd_we,
            reset       => reset,
            slv_cs      => slv_cs,
            slv_din     => slv_din,
            slv_we      => slv_we,
            tx_ack      => tx_ack,
            bus_addr    => bus_addr,
            bus_dout    => bus_dout,
            bus_rd      => bus_rd,
            bus_request => bus_request,
            bus_we      => bus_we,
            response    => response,
            response_en => response_en,
            slv_ack     => slv_ack
         );
   END GENERATE g0;

   g1: IF simulate_g GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : buscmd_b32 USE ENTITY IP006_lib.buscmd_b32;
   -- pragma synthesis_on

   BEGIN
      I1 : buscmd_b32
         GENERIC MAP (
            COMMANDS => commandfile_g
         )
         PORT MAP (
            bus_addr    => bus_addr,
            bus_we      => bus_we,
            bus_dout    => bus_dout,
            bus_rd      => bus_rd,
            bus_din     => bus_din,
            clk         => clk,
            reset       => reset,
            bus_ack     => bus_ack,
            eof         => eof,
            bus_request => bus_request,
            bus_grant   => bus_grant
         );
   END GENERATE g1;

END struct;
